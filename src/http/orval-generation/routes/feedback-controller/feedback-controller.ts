/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * Auto Cars - Backend
 * Cars seller API
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { customFetch } from '../../../custom-instance-fetch'
import type {
  CreateFeedbackByAdIdBodyDto,
  CreateFeedbackByAdResponseDto,
  FindAllFeedbacksByAdId200,
  FindAllFeedbacksByAdIdParams,
  SwaggerBadRequestDto,
} from '../../schemas'

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

export const getFindAllFeedbacksByAdIdUrl = (id: string, params?: FindAllFeedbacksByAdIdParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  return normalizedParams.size ? `/feedback/ad/${id}?${normalizedParams.toString()}` : `/feedback/ad/${id}`
}

export const findAllFeedbacksByAdId = async (
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: RequestInit,
): Promise<FindAllFeedbacksByAdId200> => {
  return customFetch<FindAllFeedbacksByAdId200>(getFindAllFeedbacksByAdIdUrl(id, params), {
    ...options,
    method: 'GET',
  })
}

export const getFindAllFeedbacksByAdIdQueryKey = (id: string, params?: FindAllFeedbacksByAdIdParams) => {
  return [`/feedback/ad/${id}`, ...(params ? [params] : [])] as const
}

export const getFindAllFeedbacksByAdIdInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllFeedbacksByAdIdQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>> = ({ signal }) =>
    findAllFeedbacksByAdId(id, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, networkMode: 'always', ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllFeedbacksByAdIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>>
export type FindAllFeedbacksByAdIdInfiniteQueryError = SwaggerBadRequestDto

export function useFindAllFeedbacksByAdIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params: undefined | FindAllFeedbacksByAdIdParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
          TError,
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllFeedbacksByAdIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
          TError,
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllFeedbacksByAdIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllFeedbacksByAdIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllFeedbacksByAdIdInfiniteQueryOptions(id, params, options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindAllFeedbacksByAdIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllFeedbacksByAdIdQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>> = ({ signal }) =>
    findAllFeedbacksByAdId(id, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, networkMode: 'always', ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllFeedbacksByAdIdQueryResult = NonNullable<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>>
export type FindAllFeedbacksByAdIdQueryError = SwaggerBadRequestDto

export function useFindAllFeedbacksByAdId<
  TData = Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params: undefined | FindAllFeedbacksByAdIdParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
          TError,
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllFeedbacksByAdId<
  TData = Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
          TError,
          Awaited<ReturnType<typeof findAllFeedbacksByAdId>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllFeedbacksByAdId<
  TData = Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllFeedbacksByAdId<
  TData = Awaited<ReturnType<typeof findAllFeedbacksByAdId>>,
  TError = SwaggerBadRequestDto,
>(
  id: string,
  params?: FindAllFeedbacksByAdIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllFeedbacksByAdId>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllFeedbacksByAdIdQueryOptions(id, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getCreateFeedbackByAdIdUrl = (id: string) => {
  return `/feedback/ad/${id}`
}

export const createFeedbackByAdId = async (
  id: string,
  createFeedbackByAdIdBodyDto: CreateFeedbackByAdIdBodyDto,
  options?: RequestInit,
): Promise<CreateFeedbackByAdResponseDto> => {
  return customFetch<CreateFeedbackByAdResponseDto>(getCreateFeedbackByAdIdUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createFeedbackByAdIdBodyDto),
  })
}

export const getCreateFeedbackByAdIdMutationOptions = <TError = SwaggerBadRequestDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFeedbackByAdId>>,
    TError,
    { id: string; data: CreateFeedbackByAdIdBodyDto },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFeedbackByAdId>>,
  TError,
  { id: string; data: CreateFeedbackByAdIdBodyDto },
  TContext
> => {
  const mutationKey = ['createFeedbackByAdId']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFeedbackByAdId>>,
    { id: string; data: CreateFeedbackByAdIdBodyDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return createFeedbackByAdId(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateFeedbackByAdIdMutationResult = NonNullable<Awaited<ReturnType<typeof createFeedbackByAdId>>>
export type CreateFeedbackByAdIdMutationBody = CreateFeedbackByAdIdBodyDto
export type CreateFeedbackByAdIdMutationError = SwaggerBadRequestDto

export const useCreateFeedbackByAdId = <TError = SwaggerBadRequestDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFeedbackByAdId>>,
    TError,
    { id: string; data: CreateFeedbackByAdIdBodyDto },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<
  Awaited<ReturnType<typeof createFeedbackByAdId>>,
  TError,
  { id: string; data: CreateFeedbackByAdIdBodyDto },
  TContext
> => {
  const mutationOptions = getCreateFeedbackByAdIdMutationOptions(options)

  return useMutation(mutationOptions)
}
