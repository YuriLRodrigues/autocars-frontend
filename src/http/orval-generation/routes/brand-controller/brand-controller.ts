/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * Auto Cars - Backend
 * Cars seller API
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { customFetch } from '../../../custom-instance-fetch'
import type {
  CreateBrandBodyDto,
  CreateBrandResponseDto,
  DeleteBrandResponseDto,
  FindAllBrands200,
  FindAllBrandsParams,
  SwaggerBadRequestDto,
  SwaggerNotAllowedDto,
  SwaggerResourceAlreadyExistsDto,
  SwaggerResourceNotFoundDto,
  UpdateBrandBodyDto,
  UpdateBrandResponseDto,
} from '../../schemas'

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

export const getCreateBrandUrl = () => {
  return `/brand`
}

export const createBrand = async (
  createBrandBodyDto: CreateBrandBodyDto,
  options?: RequestInit,
): Promise<CreateBrandResponseDto> => {
  return customFetch<CreateBrandResponseDto>(getCreateBrandUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createBrandBodyDto),
  })
}

export const getCreateBrandMutationOptions = <
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createBrand>>, TError, { data: CreateBrandBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof createBrand>>, TError, { data: CreateBrandBodyDto }, TContext> => {
  const mutationKey = ['createBrand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBrand>>, { data: CreateBrandBodyDto }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return createBrand(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateBrandMutationResult = NonNullable<Awaited<ReturnType<typeof createBrand>>>
export type CreateBrandMutationBody = CreateBrandBodyDto
export type CreateBrandMutationError =
  | SwaggerBadRequestDto
  | SwaggerNotAllowedDto
  | SwaggerResourceNotFoundDto
  | SwaggerResourceAlreadyExistsDto

export const useCreateBrand = <
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createBrand>>, TError, { data: CreateBrandBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<Awaited<ReturnType<typeof createBrand>>, TError, { data: CreateBrandBodyDto }, TContext> => {
  const mutationOptions = getCreateBrandMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getFindAllBrandsUrl = (params?: FindAllBrandsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  return normalizedParams.size ? `/brand?${normalizedParams.toString()}` : `/brand`
}

export const findAllBrands = async (params?: FindAllBrandsParams, options?: RequestInit): Promise<FindAllBrands200> => {
  return customFetch<FindAllBrands200>(getFindAllBrandsUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getFindAllBrandsQueryKey = (params?: FindAllBrandsParams) => {
  return [`/brand`, ...(params ? [params] : [])] as const
}

export const getFindAllBrandsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllBrandsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllBrands>>> = ({ signal }) =>
    findAllBrands(params, { signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findAllBrands>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllBrandsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findAllBrands>>>
export type FindAllBrandsInfiniteQueryError = SwaggerBadRequestDto

export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(
  params: undefined | FindAllBrandsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllBrands>>,
          TError,
          Awaited<ReturnType<typeof findAllBrands>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllBrands>>,
          TError,
          Awaited<ReturnType<typeof findAllBrands>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllBrandsInfiniteQueryOptions(params, options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindAllBrandsQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllBrands>>,
  TError = SwaggerBadRequestDto,
>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllBrandsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllBrands>>> = ({ signal }) =>
    findAllBrands(params, { signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllBrands>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof findAllBrands>>>
export type FindAllBrandsQueryError = SwaggerBadRequestDto

export function useFindAllBrands<TData = Awaited<ReturnType<typeof findAllBrands>>, TError = SwaggerBadRequestDto>(
  params: undefined | FindAllBrandsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllBrands>>,
          TError,
          Awaited<ReturnType<typeof findAllBrands>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrands<TData = Awaited<ReturnType<typeof findAllBrands>>, TError = SwaggerBadRequestDto>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findAllBrands>>,
          TError,
          Awaited<ReturnType<typeof findAllBrands>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrands<TData = Awaited<ReturnType<typeof findAllBrands>>, TError = SwaggerBadRequestDto>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllBrands<TData = Awaited<ReturnType<typeof findAllBrands>>, TError = SwaggerBadRequestDto>(
  params?: FindAllBrandsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllBrandsQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getUpdateBrandUrl = (id: string) => {
  return `/brand/${id}`
}

export const updateBrand = async (
  id: string,
  updateBrandBodyDto: UpdateBrandBodyDto,
  options?: RequestInit,
): Promise<UpdateBrandResponseDto> => {
  return customFetch<UpdateBrandResponseDto>(getUpdateBrandUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateBrandBodyDto),
  })
}

export const getUpdateBrandMutationOptions = <
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBrand>>,
    TError,
    { id: string; data: UpdateBrandBodyDto },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBrand>>,
  TError,
  { id: string; data: UpdateBrandBodyDto },
  TContext
> => {
  const mutationKey = ['updateBrand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBrand>>,
    { id: string; data: UpdateBrandBodyDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateBrand(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateBrandMutationResult = NonNullable<Awaited<ReturnType<typeof updateBrand>>>
export type UpdateBrandMutationBody = UpdateBrandBodyDto
export type UpdateBrandMutationError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto

export const useUpdateBrand = <
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBrand>>,
    TError,
    { id: string; data: UpdateBrandBodyDto },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateBrand>>,
  TError,
  { id: string; data: UpdateBrandBodyDto },
  TContext
> => {
  const mutationOptions = getUpdateBrandMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getDeleteBrandUrl = (id: string) => {
  return `/brand/delete/${id}`
}

export const deleteBrand = async (id: string, options?: RequestInit): Promise<DeleteBrandResponseDto> => {
  return customFetch<DeleteBrandResponseDto>(getDeleteBrandUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteBrandMutationOptions = <
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteBrand>>, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof deleteBrand>>, TError, { id: string }, TContext> => {
  const mutationKey = ['deleteBrand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBrand>>, { id: string }> = (props) => {
    const { id } = props ?? {}

    return deleteBrand(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteBrandMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBrand>>>

export type DeleteBrandMutationError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto

export const useDeleteBrand = <
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteBrand>>, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<Awaited<ReturnType<typeof deleteBrand>>, TError, { id: string }, TContext> => {
  const mutationOptions = getDeleteBrandMutationOptions(options)

  return useMutation(mutationOptions)
}
