/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * Auto Cars - Backend
 * Cars seller API
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { customFetch } from '../../../custom-instance-fetch'
import type {
  CreateBrandBodyDto,
  CreateBrandResponseDto,
  DeleteBrandResponseDto,
  FindAllBrandsResponseDto,
  SwaggerBadRequestDto,
  SwaggerNotAllowedDto,
  SwaggerResourceAlreadyExistsDto,
  SwaggerResourceNotFoundDto,
  UpdateBrandBodyDto,
  UpdateBrandResponseDto,
} from '../../schemas'

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

export const getCreateBrandUrl = () => {
  return `http://localhost:3333/brand`
}

export const createBrand = async (
  createBrandBodyDto: CreateBrandBodyDto,
  options?: RequestInit,
): Promise<CreateBrandResponseDto> => {
  return customFetch<CreateBrandResponseDto>(getCreateBrandUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createBrandBodyDto),
  })
}

export const getCreateBrandMutationOptions = <
  TData = Awaited<ReturnType<typeof createBrand>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateBrandBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['createBrand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBrand>>, { data: CreateBrandBodyDto }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return createBrand(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: CreateBrandBodyDto }, TContext>
}

export type CreateBrandMutationResult = NonNullable<Awaited<ReturnType<typeof createBrand>>>
export type CreateBrandMutationBody = CreateBrandBodyDto
export type CreateBrandMutationError =
  | SwaggerBadRequestDto
  | SwaggerNotAllowedDto
  | SwaggerResourceNotFoundDto
  | SwaggerResourceAlreadyExistsDto

export const useCreateBrand = <
  TData = Awaited<ReturnType<typeof createBrand>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateBrandBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { data: CreateBrandBodyDto }, TContext> => {
  const mutationOptions = getCreateBrandMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getUpdateBrandUrl = () => {
  return `http://localhost:3333/brand`
}

export const updateBrand = async (
  updateBrandBodyDto: UpdateBrandBodyDto,
  options?: RequestInit,
): Promise<UpdateBrandResponseDto> => {
  return customFetch<UpdateBrandResponseDto>(getUpdateBrandUrl(), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateBrandBodyDto),
  })
}

export const getUpdateBrandMutationOptions = <
  TData = Awaited<ReturnType<typeof updateBrand>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: UpdateBrandBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['updateBrand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBrand>>, { data: UpdateBrandBodyDto }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return updateBrand(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: UpdateBrandBodyDto }, TContext>
}

export type UpdateBrandMutationResult = NonNullable<Awaited<ReturnType<typeof updateBrand>>>
export type UpdateBrandMutationBody = UpdateBrandBodyDto
export type UpdateBrandMutationError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto

export const useUpdateBrand = <
  TData = Awaited<ReturnType<typeof updateBrand>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: UpdateBrandBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { data: UpdateBrandBodyDto }, TContext> => {
  const mutationOptions = getUpdateBrandMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getFindAllBrandsUrl = () => {
  return `http://localhost:3333/brand`
}

export const findAllBrands = async (options?: RequestInit): Promise<FindAllBrandsResponseDto[]> => {
  return customFetch<FindAllBrandsResponseDto[]>(getFindAllBrandsUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getFindAllBrandsQueryKey = () => {
  return [`http://localhost:3333/brand`] as const
}

export const getFindAllBrandsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllBrandsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllBrands>>> = ({ signal }) =>
    findAllBrands({ signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findAllBrands>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllBrandsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findAllBrands>>>
export type FindAllBrandsInfiniteQueryError = SwaggerBadRequestDto

export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(options: {
  query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllBrandsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllBrands>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllBrandsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindAllBrandsQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllBrands>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllBrandsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllBrands>>> = ({ signal }) =>
    findAllBrands({ signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllBrands>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof findAllBrands>>>
export type FindAllBrandsQueryError = SwaggerBadRequestDto

export function useFindAllBrands<
  TData = Awaited<ReturnType<typeof findAllBrands>>,
  TError = SwaggerBadRequestDto,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrands<
  TData = Awaited<ReturnType<typeof findAllBrands>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllBrands<
  TData = Awaited<ReturnType<typeof findAllBrands>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllBrands<
  TData = Awaited<ReturnType<typeof findAllBrands>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllBrands>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllBrandsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getDeleteBrandUrl = (id: string) => {
  return `http://localhost:3333/brand/${id}`
}

export const deleteBrand = async (id: string, options?: RequestInit): Promise<DeleteBrandResponseDto> => {
  return customFetch<DeleteBrandResponseDto>(getDeleteBrandUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteBrandMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteBrand>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['deleteBrand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBrand>>, { id: string }> = (props) => {
    const { id } = props ?? {}

    return deleteBrand(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { id: string }, TContext>
}

export type DeleteBrandMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBrand>>>

export type DeleteBrandMutationError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto

export const useDeleteBrand = <
  TData = Awaited<ReturnType<typeof deleteBrand>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { id: string }, TContext> => {
  const mutationOptions = getDeleteBrandMutationOptions(options)

  return useMutation(mutationOptions)
}
