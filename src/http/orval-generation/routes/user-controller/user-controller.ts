/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * Auto Cars - Backend
 * Cars seller API
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { customFetch } from '../../../custom-instance-fetch'
import type {
  DeleteOwnUserResponseDto,
  DeleteUserResponseDto,
  FindAllTopSellersResponseDto,
  FindAllUsers200,
  FindAllUsersParams,
  ForgotPasswordBodyDto,
  ForgotResponseDto,
  HandleActiveUserResponseDto,
  MeDto,
  NewPasswordBodyDto,
  NewPasswordParams,
  NewPasswordResponseDto,
  SignInBodyDto,
  SignInResponseDto,
  SignUpBodyDto,
  SignUpResponseDto,
  SwaggerBadRequestDto,
  SwaggerInvalidPasswordResetTokenDto,
  SwaggerNotAllowedDto,
  SwaggerResourceAlreadyExistsDto,
  SwaggerResourceNotFoundDto,
  UpdateOwnUserBodyDto,
  UpdateOwnUserResponseDto,
} from '../../schemas'

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

export const getHandleActiveUserUrl = (id: string) => {
  return `http://localhost:3333/user/handle-active/${id}`
}

export const handleActiveUser = async (id: string, options?: RequestInit): Promise<HandleActiveUserResponseDto> => {
  return customFetch<HandleActiveUserResponseDto>(getHandleActiveUserUrl(id), {
    ...options,
    method: 'PATCH',
  })
}

export const getHandleActiveUserMutationOptions = <
  TData = Awaited<ReturnType<typeof handleActiveUser>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['handleActiveUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof handleActiveUser>>, { id: string }> = (props) => {
    const { id } = props ?? {}

    return handleActiveUser(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { id: string }, TContext>
}

export type HandleActiveUserMutationResult = NonNullable<Awaited<ReturnType<typeof handleActiveUser>>>

export type HandleActiveUserMutationError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto

export const useHandleActiveUser = <
  TData = Awaited<ReturnType<typeof handleActiveUser>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { id: string }, TContext> => {
  const mutationOptions = getHandleActiveUserMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getDeleteOwnUserUrl = () => {
  return `http://localhost:3333/user/own`
}

export const deleteOwnUser = async (options?: RequestInit): Promise<DeleteOwnUserResponseDto> => {
  return customFetch<DeleteOwnUserResponseDto>(getDeleteOwnUserUrl(), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteOwnUserMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteOwnUser>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['deleteOwnUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOwnUser>>, void> = () => {
    return deleteOwnUser(requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, void, TContext>
}

export type DeleteOwnUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOwnUser>>>

export type DeleteOwnUserMutationError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto

export const useDeleteOwnUser = <
  TData = Awaited<ReturnType<typeof deleteOwnUser>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getDeleteOwnUserMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getDeleteUserUrl = (id: string) => {
  return `http://localhost:3333/user/manage/${id}`
}

export const deleteUser = async (id: string, options?: RequestInit): Promise<DeleteUserResponseDto> => {
  return customFetch<DeleteUserResponseDto>(getDeleteUserUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteUserMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteUser>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['deleteUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, { id: string }> = (props) => {
    const { id } = props ?? {}

    return deleteUser(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { id: string }, TContext>
}

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>

export type DeleteUserMutationError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto

export const useDeleteUser = <
  TData = Awaited<ReturnType<typeof deleteUser>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { id: string }, TContext> => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getFindAllTopSellersUrl = () => {
  return `http://localhost:3333/user/top-sellers`
}

export const findAllTopSellers = async (options?: RequestInit): Promise<FindAllTopSellersResponseDto[]> => {
  return customFetch<FindAllTopSellersResponseDto[]>(getFindAllTopSellersUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getFindAllTopSellersQueryKey = () => {
  return [`http://localhost:3333/user/top-sellers`] as const
}

export const getFindAllTopSellersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findAllTopSellers>>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllTopSellersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllTopSellers>>> = ({ signal }) =>
    findAllTopSellers({ signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findAllTopSellers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllTopSellersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findAllTopSellers>>>
export type FindAllTopSellersInfiniteQueryError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto

export function useFindAllTopSellersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllTopSellers>>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options: {
  query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllTopSellersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllTopSellers>>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllTopSellersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllTopSellers>>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllTopSellersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllTopSellers>>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllTopSellersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindAllTopSellersQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllTopSellers>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllTopSellersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllTopSellers>>> = ({ signal }) =>
    findAllTopSellers({ signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllTopSellers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllTopSellersQueryResult = NonNullable<Awaited<ReturnType<typeof findAllTopSellers>>>
export type FindAllTopSellersQueryError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto

export function useFindAllTopSellers<
  TData = Awaited<ReturnType<typeof findAllTopSellers>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllTopSellers<
  TData = Awaited<ReturnType<typeof findAllTopSellers>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllTopSellers<
  TData = Awaited<ReturnType<typeof findAllTopSellers>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllTopSellers<
  TData = Awaited<ReturnType<typeof findAllTopSellers>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllTopSellers>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllTopSellersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindAllUsersUrl = (params?: FindAllUsersParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  return normalizedParams.size
    ? `http://localhost:3333/user/find-all?${normalizedParams.toString()}`
    : `http://localhost:3333/user/find-all`
}

export const findAllUsers = async (params?: FindAllUsersParams, options?: RequestInit): Promise<FindAllUsers200> => {
  return customFetch<FindAllUsers200>(getFindAllUsersUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getFindAllUsersQueryKey = (params?: FindAllUsersParams) => {
  return [`http://localhost:3333/user/find-all`, ...(params ? [params] : [])] as const
}

export const getFindAllUsersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findAllUsers>>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllUsers>>> = ({ signal }) =>
    findAllUsers(params, { signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findAllUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findAllUsers>>>
export type FindAllUsersInfiniteQueryError = SwaggerBadRequestDto | SwaggerNotAllowedDto

export function useFindAllUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllUsers>>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params: undefined | FindAllUsersParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>, 'initialData'>
    request?: SecondParameter<typeof customFetch>
  },
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllUsers>>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>, 'initialData'>
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllUsers>>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findAllUsers>>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllUsersInfiniteQueryOptions(params, options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindAllUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllUsers>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindAllUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllUsers>>> = ({ signal }) =>
    findAllUsers(params, { signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof findAllUsers>>>
export type FindAllUsersQueryError = SwaggerBadRequestDto | SwaggerNotAllowedDto

export function useFindAllUsers<
  TData = Awaited<ReturnType<typeof findAllUsers>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params: undefined | FindAllUsersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>, 'initialData'>
    request?: SecondParameter<typeof customFetch>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllUsers<
  TData = Awaited<ReturnType<typeof findAllUsers>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>, 'initialData'>
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindAllUsers<
  TData = Awaited<ReturnType<typeof findAllUsers>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindAllUsers<
  TData = Awaited<ReturnType<typeof findAllUsers>>,
  TError = SwaggerBadRequestDto | SwaggerNotAllowedDto,
>(
  params?: FindAllUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllUsers>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllUsersQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getForgotPasswordUrl = () => {
  return `http://localhost:3333/user/forgot-password`
}

export const forgotPassword = async (
  forgotPasswordBodyDto: ForgotPasswordBodyDto,
  options?: RequestInit,
): Promise<ForgotResponseDto> => {
  return customFetch<ForgotResponseDto>(getForgotPasswordUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(forgotPasswordBodyDto),
  })
}

export const getForgotPasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof forgotPassword>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ForgotPasswordBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['forgotPassword']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPassword>>, { data: ForgotPasswordBodyDto }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return forgotPassword(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ForgotPasswordBodyDto },
    TContext
  >
}

export type ForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPassword>>>
export type ForgotPasswordMutationBody = ForgotPasswordBodyDto
export type ForgotPasswordMutationError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto

export const useForgotPassword = <
  TData = Awaited<ReturnType<typeof forgotPassword>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ForgotPasswordBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { data: ForgotPasswordBodyDto }, TContext> => {
  const mutationOptions = getForgotPasswordMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getNewPasswordUrl = (params: NewPasswordParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  return normalizedParams.size
    ? `http://localhost:3333/user/new-password?${normalizedParams.toString()}`
    : `http://localhost:3333/user/new-password`
}

export const newPassword = async (
  newPasswordBodyDto: NewPasswordBodyDto,
  params: NewPasswordParams,
  options?: RequestInit,
): Promise<NewPasswordResponseDto> => {
  return customFetch<NewPasswordResponseDto>(getNewPasswordUrl(params), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(newPasswordBodyDto),
  })
}

export const getNewPasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof newPassword>>,
  TError = SwaggerBadRequestDto | SwaggerInvalidPasswordResetTokenDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: NewPasswordBodyDto; params: NewPasswordParams }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['newPassword']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof newPassword>>,
    { data: NewPasswordBodyDto; params: NewPasswordParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return newPassword(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: NewPasswordBodyDto; params: NewPasswordParams },
    TContext
  >
}

export type NewPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof newPassword>>>
export type NewPasswordMutationBody = NewPasswordBodyDto
export type NewPasswordMutationError = SwaggerBadRequestDto | SwaggerInvalidPasswordResetTokenDto

export const useNewPassword = <
  TData = Awaited<ReturnType<typeof newPassword>>,
  TError = SwaggerBadRequestDto | SwaggerInvalidPasswordResetTokenDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: NewPasswordBodyDto; params: NewPasswordParams }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { data: NewPasswordBodyDto; params: NewPasswordParams }, TContext> => {
  const mutationOptions = getNewPasswordMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getSignInUrl = () => {
  return `http://localhost:3333/user/sign-in`
}

export const signIn = async (signInBodyDto: SignInBodyDto, options?: RequestInit): Promise<SignInResponseDto> => {
  return customFetch<SignInResponseDto>(getSignInUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(signInBodyDto),
  })
}

export const getSignInMutationOptions = <
  TData = Awaited<ReturnType<typeof signIn>>,
  TError = SwaggerBadRequestDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SignInBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['signIn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signIn>>, { data: SignInBodyDto }> = (props) => {
    const { data } = props ?? {}

    return signIn(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: SignInBodyDto }, TContext>
}

export type SignInMutationResult = NonNullable<Awaited<ReturnType<typeof signIn>>>
export type SignInMutationBody = SignInBodyDto
export type SignInMutationError = SwaggerBadRequestDto | SwaggerResourceAlreadyExistsDto

export const useSignIn = <
  TData = Awaited<ReturnType<typeof signIn>>,
  TError = SwaggerBadRequestDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SignInBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { data: SignInBodyDto }, TContext> => {
  const mutationOptions = getSignInMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getSignUpUrl = () => {
  return `http://localhost:3333/user/sign-up`
}

export const signUp = async (signUpBodyDto: SignUpBodyDto, options?: RequestInit): Promise<SignUpResponseDto> => {
  return customFetch<SignUpResponseDto>(getSignUpUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(signUpBodyDto),
  })
}

export const getSignUpMutationOptions = <
  TData = Awaited<ReturnType<typeof signUp>>,
  TError = SwaggerBadRequestDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SignUpBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['signUp']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signUp>>, { data: SignUpBodyDto }> = (props) => {
    const { data } = props ?? {}

    return signUp(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: SignUpBodyDto }, TContext>
}

export type SignUpMutationResult = NonNullable<Awaited<ReturnType<typeof signUp>>>
export type SignUpMutationBody = SignUpBodyDto
export type SignUpMutationError = SwaggerBadRequestDto | SwaggerResourceAlreadyExistsDto

export const useSignUp = <
  TData = Awaited<ReturnType<typeof signUp>>,
  TError = SwaggerBadRequestDto | SwaggerResourceAlreadyExistsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SignUpBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { data: SignUpBodyDto }, TContext> => {
  const mutationOptions = getSignUpMutationOptions(options)

  return useMutation(mutationOptions)
}
export const getMeUrl = () => {
  return `http://localhost:3333/user/me`
}

export const me = async (options?: RequestInit): Promise<MeDto> => {
  return customFetch<MeDto>(getMeUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getMeQueryKey = () => {
  return [`http://localhost:3333/user/me`] as const
}

export const getMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) => me({ signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof me>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>
export type MeInfiniteQueryError = SwaggerBadRequestDto

export function useMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = SwaggerBadRequestDto,
>(options: {
  query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = SwaggerBadRequestDto,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMeInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getMeQueryOptions = <TData = Awaited<ReturnType<typeof me>>, TError = SwaggerBadRequestDto>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) => me({ signal, ...requestOptions })

  return { queryKey, queryFn, networkMode: 'always', ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof me>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>
export type MeQueryError = SwaggerBadRequestDto

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = SwaggerBadRequestDto>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = SwaggerBadRequestDto>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, TData>, 'initialData'>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = SwaggerBadRequestDto>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = SwaggerBadRequestDto>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMeQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getUpdateOwnUserUrl = () => {
  return `http://localhost:3333/user/update-own`
}

export const updateOwnUser = async (
  updateOwnUserBodyDto: UpdateOwnUserBodyDto,
  options?: RequestInit,
): Promise<UpdateOwnUserResponseDto> => {
  return customFetch<UpdateOwnUserResponseDto>(getUpdateOwnUserUrl(), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateOwnUserBodyDto),
  })
}

export const getUpdateOwnUserMutationOptions = <
  TData = Awaited<ReturnType<typeof updateOwnUser>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: UpdateOwnUserBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}) => {
  const mutationKey = ['updateOwnUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOwnUser>>, { data: UpdateOwnUserBodyDto }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return updateOwnUser(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: UpdateOwnUserBodyDto },
    TContext
  >
}

export type UpdateOwnUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateOwnUser>>>
export type UpdateOwnUserMutationBody = UpdateOwnUserBodyDto
export type UpdateOwnUserMutationError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto

export const useUpdateOwnUser = <
  TData = Awaited<ReturnType<typeof updateOwnUser>>,
  TError = SwaggerBadRequestDto | SwaggerResourceNotFoundDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: UpdateOwnUserBodyDto }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationResult<TData, TError, { data: UpdateOwnUserBodyDto }, TContext> => {
  const mutationOptions = getUpdateOwnUserMutationOptions(options)

  return useMutation(mutationOptions)
}
